/* eslint-disable @typescript-eslint/no-explicit-any */
import { QueryKey } from "@tanstack/react-query";
import {
  UseMutationFnWithParams,
  UseMutationFnWithoutParams,
  createUseMutation,
} from "./create-use-mutation";
import {
  ServiceFunction,
  UseQueryFnWithParams,
  UseQueryFnWithoutParams,
  createUseQuery,
} from "./create-use-query";
import {
  UseInfiniteQueryFnWithParams,
  createUseInfiniteQuery,
} from "./create-use-infinite-query";

type FunctionConstraint<T> = {
  [K in keyof T]: (...args: any[]) => any;
};

/**
 * Dynamically generates query and mutation hooks, along with query key generators,
 * for each function in a given service object. This utility function facilitates the
 * integration of service layer functions with React Query's useQuery and useMutation hooks.
 *
 * @template T The type of the service object, constrained to an object where each property
 * is a function that might take any number of arguments and return a Promise of any type.
 * @param {T} service An object containing service functions. Each function in this object
 * represents a distinct API call or data fetching logic that can be transformed into
 * a query or a mutation.
 * @param {string} queryKeyPrefix A string prefix used to construct the query keys for
 * each generated query. This prefix helps in namespacing the queries and avoiding key collisions.
 *
 * @returns {Queries} An object where each key corresponds to a key in the input service object,
 * and each value is an object containing:
 * - `useQuery`: A custom hook generated by `createUseQuery`, tailored to invoke the corresponding
 *   service function. If the service function does not expect parameters, `useQuery` will be a
 *   function that takes optional React Query options. If the service function expects parameters,
 *   `useQuery` will be a function that expects those parameters followed by optional React Query options.
 * - `useMutation`: A custom hook generated by `createUseMutation`, tailored to invoke the corresponding
 *   service function. Similar to `useQuery`, the shape of `useMutation` depends on whether the service
 *   function expects parameters.
 * - `queryKey`: A function that generates a query key for the corresponding service function. The generated
 *   query key is an array consisting of the `queryKeyPrefix`, the key corresponding to the service function,
 *   and the parameters passed to the service function, if any.
 *
 * The `Queries` type is a mapped type where each property of the input service object is mapped to an object
 * containing the `useQuery`, `useMutation`, and `queryKey` properties as described above.
 *
 * @example
 * ```tsx
 * const userService = {
 *   getUser: (params: {id: string}) => fetch(`/api/users/${params.id}`).then(res => res.json()),
 *   updateUser: (userId, userData) => fetch(`/api/users/${userId}`, {
 *     method: 'POST',
 *     body: JSON.stringify(userData),
 *   }).then(res => res.json()),
 * };
 *
 * const { getUser, updateUser } = createQueriesFromService(userService, 'user');
 *
 * // Inside a component
 * const Foo = () => {
 *  const { data: user, isLoading } = getUser.useQuery({ id: "123" });
 *  const { mutate: updateUser } = updateUser.useMutation();
 *
 *  return <div>...</div>
 * }
 * ```
 */
function createQueriesFromService<T extends FunctionConstraint<T>>(
  service: T,
  queryKeyPrefix: string
) {
  type ServiceToQueryFn<Params, TFunction> = TFunction extends ServiceFunction<
    infer TParams,
    infer TResult
  >
    ? Params extends []
      ? UseQueryFnWithoutParams<TResult>
      : UseQueryFnWithParams<TParams, TResult>
    : never;

  type ServiceToMutationFn<Params, TFunction> =
    TFunction extends ServiceFunction<infer TParams, infer TResult>
      ? Params extends []
        ? UseMutationFnWithoutParams<TResult>
        : UseMutationFnWithParams<TParams, TResult>
      : never;

  type ServiceToInfiniteQueryFn<Params, TFunction> =
    TFunction extends ServiceFunction<infer TParams, infer TResult>
      ? UseInfiniteQueryFnWithParams<TParams, TResult>
      : never;

  type Queries = {
    [K in keyof T]: {
      useQuery: ServiceToQueryFn<Parameters<T[K]>, T[K]>;
      useMutation: ServiceToMutationFn<Parameters<T[K]>, T[K]>;
      useInfiniteQuery: ServiceToInfiniteQueryFn<Parameters<T[K]>, T[K]>; // Add infinite query
      queryKey: (
        params: Parameters<T[K]> extends [infer Params] ? Params : void
      ) => QueryKey;
    };
  };

  const queries: Queries = {} as Queries;

  type QueryKeyFn<TParams> = (params: TParams) => QueryKey;

  Object.keys(service).forEach((key) => {
    const serviceFn = service[key as keyof T];
    if (typeof serviceFn === "function") {
      // Determine if the service function expects parameters
      const expectsParams = serviceFn.length > 0;

      // Use an appropriate type assertion based on whether the service function expects parameters
      if (expectsParams) {
        (queries[key as keyof T] as any) = {
          useQuery: createUseQuery({
            expectsParams: true,
            serviceFn,
            queryKey: (params) => [queryKeyPrefix, key, params],
          }) as UseQueryFnWithParams<any, any>,
          useMutation: createUseMutation(
            serviceFn as ServiceFunction<any, any>
          ) as UseMutationFnWithParams<any, any>,
          useInfiniteQuery: createUseInfiniteQuery({
            serviceFn,
            queryKey: (params) => [queryKeyPrefix, key, params],
            initialPageParam: 1,
            getNextPageParam: (lastPage) => lastPage + 1,
          }) as UseInfiniteQueryFnWithParams<any, any>,
          queryKey: ((params) => [
            queryKeyPrefix,
            key,
            params,
          ]) as QueryKeyFn<any>,
        };
      } else {
        (queries[key as keyof T] as any) = {
          useQuery: createUseQuery({
            expectsParams: false,
            serviceFn,
            queryKey: (params) => [queryKeyPrefix, key, params],
          }) as UseQueryFnWithoutParams<any>,
          useMutation: createUseMutation(
            serviceFn as ServiceFunction<undefined, any>
          ) as UseMutationFnWithoutParams<any>,
          queryKey: ((params) => [
            queryKeyPrefix,
            key,
            params,
          ]) as QueryKeyFn<undefined>,
        };
      }
    }
  });

  return queries as Queries;
}

export { createQueriesFromService };
